import {
  readdirSync,
  statSync,
  readFileSync,
  existsSync,
  mkdirSync,
  writeFileSync,
} from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import { format } from "prettier";

const __dirname = dirname(fileURLToPath(import.meta.url));

const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */`;

function getDirectories(path) {
  if (!existsSync(path)) {
    return [];
  }

  return readdirSync(path).filter(function (file) {
    return statSync(join(path, file)).isDirectory();
  });
}

function getFiles(path) {
  return readdirSync(path).filter(function (file) {
    return statSync(join(path, file)).isFile();
  });
}

function parseTransactionRun(filePath) {
  try {
    const content = readFileSync(filePath, "utf8");
    const broadcastData = JSON.parse(content);
    return broadcastData.transactions || [];
  } catch (error) {
    console.warn(`Warning: Could not parse ${filePath}:`, error.message);
    return [];
  }
}

function getDeploymentHistory(broadcastPath) {
  const files = getFiles(broadcastPath);
  const deploymentHistory = new Map();

  // Sort files to process them in chronological order
  const runFiles = files
    .filter(
      (file) =>
        file.startsWith("run-") &&
        file.endsWith(".json") &&
        !file.includes("run-latest")
    )
    .sort((a, b) => {
      // Extract run numbers and compare them
      const runA = parseInt(a.match(/run-(\d+)/)?.[1] || "0");
      const runB = parseInt(b.match(/run-(\d+)/)?.[1] || "0");
      return runA - runB;
    });

  for (const file of runFiles) {
    const transactions = parseTransactionRun(join(broadcastPath, file));

    for (const tx of transactions) {
      if (tx.transactionType === "CREATE") {
        // Handle deployment script contracts
        deploymentHistory.set(tx.contractAddress, {
          contractName: tx.contractName,
          address: tx.contractAddress,
          deploymentFile: file,
          transaction: tx,
        });
      } else if (tx.transactionType === "CALL" && tx.additionalContracts) {
        // Handle implementation contracts deployed by deployment scripts
        for (const additionalContract of tx.additionalContracts) {
          if (additionalContract.transactionType === "CREATE") {
            // Map deployment script names to actual contract names
            let actualContractName = mapDeploymentScriptToContract(
              tx.contractName
            );
            if (actualContractName) {
              deploymentHistory.set(additionalContract.address, {
                contractName: actualContractName,
                address: additionalContract.address,
                deploymentFile: file,
                transaction: additionalContract,
                deploymentScript: tx.contractName,
              });
            }
          }
        }
      }
    }
  }

  return Array.from(deploymentHistory.values());
}

function mapDeploymentScriptToContract(deploymentScriptName) {
  const mapping = {
    DeployRoboshareTokens: "RoboshareTokens",
    DeployPartnerManager: "PartnerManager",
    DeployVehicleRegistry: "VehicleRegistry",
    DeployTreasury: "Treasury",
  };
  return mapping[deploymentScriptName];
}

function getArtifactOfContract(contractName) {
  const current_path_to_artifacts = join(
    __dirname,
    "..",
    `out/${contractName}.sol`
  );

  if (!existsSync(current_path_to_artifacts)) return null;

  const artifactJson = JSON.parse(
    readFileSync(`${current_path_to_artifacts}/${contractName}.json`)
  );

  return artifactJson;
}

function getInheritedFromContracts(artifact) {
  let inheritedFromContracts = [];
  if (artifact?.ast) {
    for (const astNode of artifact.ast.nodes) {
      if (astNode.nodeType == "ContractDefinition") {
        if (astNode.baseContracts.length > 0) {
          inheritedFromContracts = astNode.baseContracts.map(
            ({ baseName }) => baseName.name
          );
        }
      }
    }
  }
  return inheritedFromContracts;
}

function getInheritedFunctions(mainArtifact) {
  const inheritedFromContracts = getInheritedFromContracts(mainArtifact);
  const inheritedFunctions = {};
  for (const inheritanceContractName of inheritedFromContracts) {
    const artifact = getArtifactOfContract(inheritanceContractName);
    if (artifact) {
      const {
        abi,
        ast: { absolutePath },
      } = artifact;
      for (const abiEntry of abi) {
        if (abiEntry.type == "function") {
          inheritedFunctions[abiEntry.name] = absolutePath;
        }
      }
    }
  }
  return inheritedFunctions;
}

function getProxyMapping(chainId) {
  // Hardcoded proxy mappings from chain analysis
  // Implementation -> Proxy address mappings for upgradeable contracts
  const proxyMapping = new Map();

  if (chainId === "31337") {
    // Local development mappings
    proxyMapping.set(
      "0xa44b9f3f5bb8c278c1ee85d8f32517c6efa64b0d",
      "0x7f65d50b2915d5b2ca6cbb879cd5fe940fd44b86"
    ); // RoboshareTokens
    proxyMapping.set(
      "0x21db43cdd6fbd4998ff67af132f953747bfacb97",
      "0x9ea2f17f8e53d15c6828c2d99651b1ffe9b16e0e"
    ); // PartnerManager
    proxyMapping.set(
      "0x58fff7cf21aecd9d4b500e5490b10b07b9553e89",
      "0x3dc1ec9c2867fd75f63f089b5c9760b3d259e07d"
    ); // VehicleRegistry
    proxyMapping.set(
      "0xc05e24398c12b31ee2626ab1b9708aacd287082f",
      "0xc84678cbf0ce9cc53a1cb54c92eafe7ce0350e0a"
    ); // Treasury
  }

  return proxyMapping;
}

function processAllDeployments(broadcastPath) {
  const scriptFolders = getDirectories(broadcastPath);
  const allDeployments = new Map();
  const proxyMapping = getProxyMapping("31337");

  scriptFolders.forEach((scriptFolder) => {
    const scriptPath = join(broadcastPath, scriptFolder);
    const chainFolders = getDirectories(scriptPath);

    chainFolders.forEach((chainId) => {
      const chainPath = join(scriptPath, chainId);
      const deploymentHistory = getDeploymentHistory(chainPath);

      deploymentHistory.forEach((deployment) => {
        const timestamp = parseInt(
          deployment.deploymentFile.match(/run-(\d+)/)?.[1] || "0"
        );
        const key = `${chainId}-${deployment.contractName}`;

        // Only update if this deployment is newer
        if (
          !allDeployments.has(key) ||
          timestamp > allDeployments.get(key).timestamp
        ) {
          // Use proxy address if available, otherwise use implementation address
          const finalAddress =
            proxyMapping.get(deployment.address) || deployment.address;

          allDeployments.set(key, {
            ...deployment,
            address: finalAddress,
            implementationAddress: deployment.address,
            timestamp,
            chainId,
            deploymentScript: scriptFolder,
          });
        }
      });
    });
  });

  const allContracts = {};

  allDeployments.forEach((deployment) => {
    const { chainId, contractName } = deployment;
    const artifact = getArtifactOfContract(contractName);

    if (artifact) {
      if (!allContracts[chainId]) {
        allContracts[chainId] = {};
      }

      allContracts[chainId][contractName] = {
        address: deployment.address, // This is now the proxy address
        abi: artifact.abi,
        inheritedFunctions: getInheritedFunctions(artifact),
        deploymentFile: deployment.deploymentFile,
        deploymentScript: deployment.deploymentScript,
      };
    }
  });

  return allContracts;
}

function main() {
  const current_path_to_broadcast = join(__dirname, "..", "broadcast");
  const current_path_to_deployments = join(__dirname, "..", "deployments");

  const Deploymentchains = getFiles(current_path_to_deployments);
  const deployments = {};

  // Load existing deployments from deployments directory
  Deploymentchains.forEach((chain) => {
    if (!chain.endsWith(".json")) return;
    chain = chain.slice(0, -5);
    var deploymentObject = JSON.parse(
      readFileSync(`${current_path_to_deployments}/${chain}.json`)
    );
    deployments[chain] = deploymentObject;
  });

  // Process all deployments from all script folders
  const allGeneratedContracts = processAllDeployments(
    current_path_to_broadcast
  );

  // Update contract keys based on deployments if they exist
  Object.entries(allGeneratedContracts).forEach(([chainId, contracts]) => {
    Object.entries(contracts).forEach(([contractName, contractData]) => {
      const deployedName = deployments[chainId]?.[contractData.address];
      if (deployedName) {
        // If we have a deployment name, use it instead of the contract name
        allGeneratedContracts[chainId][deployedName] = contractData;
        delete allGeneratedContracts[chainId][contractName];
      }
    });
  });

  const NEXTJS_TARGET_DIR = "../../web/contracts/";

  // Ensure target directories exist
  if (!existsSync(NEXTJS_TARGET_DIR)) {
    mkdirSync(NEXTJS_TARGET_DIR, { recursive: true });
  }

  // Generate the deployedContracts content
  const fileContent = Object.entries(allGeneratedContracts).reduce(
    (content, [chainId, chainConfig]) => {
      return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(
        chainConfig,
        null,
        2
      )},`;
    },
    ""
  );

  // Write the files
  const fileTemplate = (importPath) => `
    ${generatedContractComment}
    import { GenericContractsDeclaration } from "${importPath}";

    const deployedContracts = {${fileContent}} as const;

    export default deployedContracts satisfies GenericContractsDeclaration;
  `;

  writeFileSync(
    `${NEXTJS_TARGET_DIR}deployedContracts.ts`,
    format(fileTemplate("~~/utils/scaffold-eth/contract"), {
      parser: "typescript",
    })
  );

  console.log(
    `üìù Updated TypeScript contract definition file on ${NEXTJS_TARGET_DIR}deployedContracts.ts`
  );
}

try {
  main();
} catch (error) {
  console.error("Error:", error);
  process.exitCode = 1;
}
